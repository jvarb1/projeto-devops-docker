name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/projeto-devops
  TERRAFORM_DIR: ./terraform

jobs:
  # Job 1: Testes Unit√°rios
  test:
    name: Testes Unit√°rios
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4

      - name: Configurar Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Instalar depend√™ncias
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Executar testes
        run: |
          pytest tests/ -v --tb=short

  # Job 2: Build e Push da Imagem Docker
  build-and-push:
    name: Build e Push Docker
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4

      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extrair metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest

      - name: Build e Push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # Job 3: Provisionar Infraestrutura
  provision-infra:
    name: Provisionar Infraestrutura
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    outputs:
      instance_ip: ${{ steps.terraform-output.outputs.instance_ip }}
    
    env:
      TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      TF_VAR_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
      TF_VAR_user_ocid: ${{ secrets.OCI_USER_OCID }}
      TF_VAR_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
      TF_VAR_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
      TF_VAR_compartment_ocid: ${{ secrets.OCI_COMPARTMENT_OCID }}
      TF_VAR_vcn_id: ${{ secrets.OCI_VCN_ID }}
      TF_VAR_subnet_id: ${{ secrets.OCI_SUBNET_ID }}
      TF_VAR_region: ${{ secrets.OCI_REGION }}
      TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4

      - name: Configurar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Verificar formata√ß√£o Terraform
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          echo "Verificando formata√ß√£o do c√≥digo Terraform..."
          terraform fmt -check -recursive || {
            echo "‚ùå ERRO: C√≥digo Terraform n√£o est√° formatado corretamente"
            echo "Execute 'terraform fmt -recursive' para corrigir"
            exit 1
          }
          echo "‚úÖ Formata√ß√£o Terraform OK"

      - name: Verificar formato da chave privada OCI
        run: |
          echo "Verificando formato da chave privada OCI..."
          if echo "${{ secrets.OCI_PRIVATE_KEY }}" | grep -q "BEGIN PRIVATE KEY"; then
            echo "‚úÖ Chave privada cont√©m BEGIN PRIVATE KEY"
          else
            echo "‚ùå ERRO: Chave privada N√ÉO cont√©m BEGIN PRIVATE KEY"
            exit 1
          fi
          if echo "${{ secrets.OCI_PRIVATE_KEY }}" | grep -q "END PRIVATE KEY"; then
            echo "‚úÖ Chave privada cont√©m END PRIVATE KEY"
          else
            echo "‚ùå ERRO: Chave privada N√ÉO cont√©m END PRIVATE KEY"
            exit 1
          fi
          KEY_LINES=$(echo "${{ secrets.OCI_PRIVATE_KEY }}" | wc -l)
          echo "üìä N√∫mero de linhas na chave: $KEY_LINES"
          if [ "$KEY_LINES" -lt 3 ]; then
            echo "‚ö†Ô∏è AVISO: Chave privada parece muito curta (menos de 3 linhas)"
          fi

      - name: Terraform Init
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          terraform init

      - name: Validar configura√ß√£o Terraform
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          echo "Validando configura√ß√£o Terraform..."
          terraform validate || {
            echo "‚ùå ERRO: Configura√ß√£o Terraform inv√°lida"
            exit 1
          }
          echo "‚úÖ Valida√ß√£o Terraform OK"

      - name: Terraform Plan
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          terraform apply -auto-approve tfplan

      - name: Obter Output do IP
        id: terraform-output
        working-directory: ${{ env.TERRAFORM_DIR }}
        run: |
          INSTANCE_IP=$(terraform output -raw instance_ip)
          if [ -z "$INSTANCE_IP" ]; then
            echo "‚ùå ERRO: N√£o foi poss√≠vel obter o IP da inst√¢ncia"
            exit 1
          fi
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
          echo "IP do servidor: $INSTANCE_IP"

      - name: Configurar SSH para verifica√ß√£o
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.terraform-output.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Aguardar servidor estar pronto
        run: |
          echo "Aguardando servidor estar pronto (Cloud-Init pode levar 2-5 minutos)..."
          INSTANCE_IP="${{ steps.terraform-output.outputs.instance_ip }}"
          SSH_USER="${{ secrets.SSH_USER }}"
          MAX_ATTEMPTS=30
          WAIT_TIME=15
          
          if [ -z "$INSTANCE_IP" ]; then
            echo "‚ùå ERRO: IP da inst√¢ncia n√£o est√° dispon√≠vel"
            exit 1
          fi
          
          # Aguardar inicial (Cloud-Init precisa de tempo)
          echo "Aguardando 60 segundos para Cloud-Init iniciar..."
          sleep 60
          
          # Tentar conectar via SSH para verificar se est√° pronto
          echo "Verificando conectividade SSH e instala√ß√£o do Docker..."
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if ssh -o StrictHostKeyChecking=no \
                   -o ConnectTimeout=10 \
                   -o UserKnownHostsFile=/dev/null \
                   -o BatchMode=yes \
                   -i ~/.ssh/deploy_key \
                   $SSH_USER@$INSTANCE_IP \
                   "docker --version && docker compose version" 2>/dev/null; then
              echo "‚úÖ Servidor est√° pronto! Docker instalado."
              exit 0
            fi
            echo "Tentativa $i/$MAX_ATTEMPTS - aguardando Cloud-Init completar..."
            sleep $WAIT_TIME
          done
          
          # Verifica√ß√£o final
          if ssh -o StrictHostKeyChecking=no \
                 -o ConnectTimeout=10 \
                 -o UserKnownHostsFile=/dev/null \
                 -o BatchMode=yes \
                 -i ~/.ssh/deploy_key \
                 $SSH_USER@$INSTANCE_IP \
                 "docker --version" 2>/dev/null; then
            echo "‚úÖ Servidor verificado e pronto para deploy!"
          else
            echo "‚ùå ERRO: Servidor n√£o est√° pronto ap√≥s $MAX_ATTEMPTS tentativas"
            echo "Cloud-Init pode ainda estar em execu√ß√£o. Verifique manualmente."
            exit 1
          fi

  # Job 4: Deploy da Aplica√ß√£o
  deploy:
    name: Deploy Autom√°tico
    needs: [build-and-push, provision-infra]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4

      - name: Configurar SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ needs.provision-infra.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Verificar conectividade SSH
        run: |
          INSTANCE_IP="${{ needs.provision-infra.outputs.instance_ip }}"
          SSH_USER="${{ secrets.SSH_USER }}"
          
          if [ -z "$INSTANCE_IP" ]; then
            echo "‚ùå ERRO: IP da inst√¢ncia n√£o est√° dispon√≠vel"
            exit 1
          fi
          
          echo "Verificando conectividade SSH com o servidor..."
          for i in {1..5}; do
            if ssh -o StrictHostKeyChecking=no \
                   -o ConnectTimeout=10 \
                   -o UserKnownHostsFile=/dev/null \
                   -o BatchMode=yes \
                   -i ~/.ssh/deploy_key \
                   $SSH_USER@$INSTANCE_IP \
                   "echo 'Conex√£o SSH OK'" 2>/dev/null; then
              echo "‚úÖ Conectividade SSH verificada"
              exit 0
            fi
            echo "Tentativa $i/5 de conex√£o SSH..."
            sleep 5
          done
          
          echo "‚ùå ERRO: N√£o foi poss√≠vel conectar ao servidor via SSH"
          exit 1

      - name: Deploy no servidor
        env:
          INSTANCE_IP: ${{ needs.provision-infra.outputs.instance_ip }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        run: |
          ssh -i ~/.ssh/deploy_key \
              -o StrictHostKeyChecking=no \
              -o ConnectTimeout=30 \
              $SSH_USER@$INSTANCE_IP << 'ENDSSH'
            set -euo pipefail
            
            echo "=========================================="
            echo "Iniciando deploy da aplica√ß√£o"
            echo "=========================================="
            
            # Criar diret√≥rio do projeto se n√£o existir
            mkdir -p ~/projeto-devops
            cd ~/projeto-devops || {
              echo "‚ùå ERRO: N√£o foi poss√≠vel acessar o diret√≥rio do projeto"
              exit 1
            }
            
            # Clonar ou atualizar reposit√≥rio
            if [ -d ".git" ]; then
              echo "Atualizando reposit√≥rio..."
              git pull origin main || {
                echo "‚ö†Ô∏è Aviso: Falha ao atualizar reposit√≥rio, continuando..."
              }
            else
              echo "Clonando reposit√≥rio..."
              git clone https://github.com/${{ github.repository }}.git . || {
                echo "‚ùå ERRO: Falha ao clonar reposit√≥rio"
                exit 1
              }
            fi
            
            # Login no Docker Hub
            echo "Fazendo login no Docker Hub..."
            echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin || {
              echo "‚ùå ERRO: Falha ao fazer login no Docker Hub"
              exit 1
            }
            
            # Baixar nova imagem
            echo "Baixando nova imagem Docker..."
            docker pull ${{ env.DOCKER_IMAGE }}:latest || {
              echo "‚ö†Ô∏è Aviso: Falha ao baixar nova imagem, usando imagem local se dispon√≠vel"
            }
            
            # Criar arquivo .env se n√£o existir
            if [ ! -f .env ]; then
              echo "Criando arquivo .env..."
              cat > .env << EOF
            DB_NAME=taskdb
            DB_USER=taskuser
            DB_PASSWORD=$(openssl rand -base64 32)
            DB_PORT=5432
            APP_PORT=8000
            DOCKER_USERNAME=$DOCKER_USERNAME
            IMAGE_TAG=latest
            EOF
            fi
            
            # Parar containers existentes
            echo "Parando containers existentes..."
            docker-compose -f docker-compose.prod.yml down || true
            
            # Iniciar containers com nova imagem
            echo "Iniciando containers..."
            docker-compose -f docker-compose.prod.yml up -d || {
              echo "‚ùå ERRO: Falha ao iniciar containers"
              docker-compose -f docker-compose.prod.yml logs
              exit 1
            }
            
            # Aguardar aplica√ß√£o estar pronta
            echo "Aguardando aplica√ß√£o estar pronta..."
            sleep 15
            
            # Verificar sa√∫de da aplica√ß√£o
            echo "Verificando sa√∫de da aplica√ß√£o..."
            HEALTH_CHECK_PASSED=false
            for i in {1..15}; do
              if curl -f -s http://localhost:8000/health > /dev/null 2>&1; then
                echo "‚úÖ Aplica√ß√£o est√° rodando e saud√°vel!"
                HEALTH_CHECK_PASSED=true
                break
              fi
              echo "Tentativa $i/15 - aguardando aplica√ß√£o..."
              sleep 5
            done
            
            if [ "$HEALTH_CHECK_PASSED" = false ]; then
              echo "‚ùå ERRO: Health check falhou ap√≥s 15 tentativas"
              echo "Logs dos containers:"
              docker-compose -f docker-compose.prod.yml logs --tail=50
              exit 1
            fi
            
            # Mostrar status
            echo "Status dos containers:"
            docker-compose -f docker-compose.prod.yml ps
            
            echo "=========================================="
            echo "‚úÖ Deploy conclu√≠do com sucesso!"
            echo "=========================================="
          ENDSSH

      - name: Verificar deploy
        run: |
          INSTANCE_IP="${{ needs.provision-infra.outputs.instance_ip }}"
          
          if [ -z "$INSTANCE_IP" ]; then
            echo "‚ùå ERRO: IP da inst√¢ncia n√£o est√° dispon√≠vel"
            exit 1
          fi
          
          echo "Verificando aplica√ß√£o em http://$INSTANCE_IP:8000/health"
          sleep 10
          
          for i in {1..5}; do
            if curl -f -s http://$INSTANCE_IP:8000/health > /dev/null 2>&1; then
              echo "‚úÖ Aplica√ß√£o est√° acess√≠vel e respondendo corretamente!"
              exit 0
            fi
            echo "Tentativa $i/5 de verifica√ß√£o externa..."
            sleep 5
          done
          
          echo "‚ö†Ô∏è Aviso: Aplica√ß√£o pode ainda estar iniciando ou h√° problema de conectividade"
          echo "Verifique manualmente: http://$INSTANCE_IP:8000/health"
          exit 1
